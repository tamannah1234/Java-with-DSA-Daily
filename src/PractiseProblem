
/*
You are given an integer array nums and an integer k.
ðŸ‘‰ Task:
Return true if there exist two distinct indices i and j such that:


nums[i] == nums[j]


|i - j| <= k


Otherwise, return false.
ðŸ“Œ Example:
nums = [1,2,3,1], k = 3 â†’ true
nums = [1,2,3,1], k = 2 â†’ false

Question 2 (Strings)
Given a string s, find the first non-repeating character and return its index.
If it doesnâ€™t exist, return -1.
ðŸ“Œ Example:
s = "leetcode" â†’ 0
s = "loveleetcode" â†’ 2

Question 3 (Binary Search / Math)
Given a sorted array of integers and a target value x, return the index where x should be inserted to keep the array sorted.
ðŸ“Œ Example:
nums = [1,3,5,6], x = 5 â†’ 2
nums = [1,3,5,6], x = 2 â†’ 1
nums = [1,3,5,6], x = 7 â†’ 4



(Binary search and at the end return low)
//Search Insert Position (Binary Search)
public static int insertAtPos(int arr[],int k){
 int low=0;int high =arr.length-1;
 while(low<=high){
     int mid = low + (high-low)/2;
     if(arr[mid]==k){
         return mid;
     }else if(arr[mid]>k){
         high = mid-1;
     }else{
         low=mid+1;
     }
   
 }
      return low;
    
}

public static int firstUniqueChar(String s){
    
    Map<Character,Integer> freq = new HashMaop<>();
    //1st pass: count freq
    for(char ch : s.toCharArray){
      freq.put(ch,freq.getOrDefault(ch,0)+1);
    }
    //2nd pass : Itearte and return unique index
    for(int i=0;i<s.length();i++){
      freq.get(s.charAt(i)==1){
          return i;
      }  
    }
    return -1;
    
}

 public boolean containsNearbyDuplicate(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {
                if (i - map.get(nums[i]) <= k) {
                    return true;
                }
            }
            // update last seen index
            map.put(nums[i], i);
        }
        return false;
    }
